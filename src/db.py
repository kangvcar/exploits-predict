"""
Module for working with a shared private database of the project.
Current Solution:
- SQLite database
- on a remote server, with sshfs access
"""

import os
import sys
import sqlite3
from datetime import datetime
from sshfs import SSHFileSystem


class InternalDB:
    """
    Class for work with internal (private) project DB.

    Current Solution:
    - SQLite database
    - store on a remote server
    - pull/push via sshfs access

    PyPi sshfs manual: https://pypi.org/project/sshfs/
    Manual for configure sshfs on remote server: /project_docs/sshfs_manual.md

    TODO: add compress/decompress .db file to bz2 archive
    TODO: add backup rotation (keep only a few copies, delete the rest)
    TODO: add output to console of current file size (before saving)
    TODO: it is possible to add a warning output if we try to push a
          file that is smaller than on the server
    """

    def __init__(self, pull=True):
        # private
        self.__SSHFS_CONFIG = {
            "host": os.environ.get("SSHFS_HOST"),
            "port": int(os.environ.get("SSHFS_PORT")),
            "username": os.environ.get("SSHFS_USERNAME"),
            "password": os.environ.get("SSHFS_PASSWORD"),
        }
        self.__DB_REMOTE_DIR = os.environ.get("DB_REMOTE_DIR")
        self.__DB_FILENAME = "exploits_predict_sqlite.db"

        # public
        self.transaction_queues = {"default": []}

        if pull:
            self.db_pull()
        else:
            self.is_local_state = False

    def db_pull(self):
        """Pull copy of db from remote server"""

        fs = SSHFileSystem(**self.__SSHFS_CONFIG)
        fs.get_file(f"{self.__DB_REMOTE_DIR}{self.__DB_FILENAME}", self.__DB_FILENAME)
        self.is_local_state = True

    def db_push(self):
        """Push db to remote server. The previous version of the database
        is archived (by renaming the .db file)"""

        fs = SSHFileSystem(**self.__SSHFS_CONFIG)

        # archive previous version of db
        if fs.exists(f"{self.__DB_REMOTE_DIR}{self.__DB_FILENAME}"):
            fs.rename(
                f"{self.__DB_REMOTE_DIR}{self.__DB_FILENAME}",
                f"{self.__DB_REMOTE_DIR}{self.__DB_FILENAME}_\
                      {datetime.now().strftime('%Y%m%d_%H%M')}.bak",
            )
        else:
            print(
                "Warning: A previous version of the db file was not \
                   found on the remote server."
            )

        fs.put_file(self.__DB_FILENAME, f"{self.__DB_REMOTE_DIR}{self.__DB_FILENAME}")

        self.is_local_state = False

    def get_connect(self, with_cursor=True):
        """Get (connect, cursor) or connect only to db. Without try/except"""
        sqlite_con = sqlite3.connect(self.__DB_FILENAME)
        if with_cursor:
            return sqlite_con, sqlite_con.cursor()
        else:
            return sqlite_con

    @staticmethod
    def write_query_no_commit(sqlite_cur, sql_query, placeholder=None):
        """Support named and qmark styles placeholders"""

        if isinstance(sql_query, list):
            for query in sql_query:
                sqlite_cur.execute(query)

        elif placeholder is None:
            sqlite_cur.execute(sql_query)

        elif isinstance(placeholder, tuple):
            sqlite_cur.execute(sql_query, placeholder)

        elif isinstance(placeholder, list):
            sqlite_cur.executemany(sql_query, placeholder)

    def safe_write_query(
        self,
        sql_query=None,
        placeholder=None,
        multiple_sql_queries=None,
        verbose=False,
        sys_exit=True,
    ):
        """Support named and qmark styles placeholders"""
        try:
            sqlite_con, sqlite_cur = self.get_connect()

            if sql_query:
                InternalDB.write_query_no_commit(sqlite_cur, sql_query, placeholder)
            elif multiple_sql_queries:
                for sql_query, placeholder in multiple_sql_queries:
                    InternalDB.write_query_no_commit(sqlite_cur, sql_query, placeholder)

            sqlite_con.commit()
            sqlite_cur.close()

            if verbose:
                print("All operation complete.")

        except sqlite3.Error as error:
            print("Error connection to sqlite:\n", error)
            if sys_exit:
                sys.exit(str(error))
        finally:
            if "sqlite_con" in locals() and sqlite_con:
                sqlite_con.close()
                if verbose:
                    print("Connection to SQLite closed.")

    def safe_read_query(self, sql_query, placeholder=None, verbose=False, sys_exit=True):
        """Support named and qmark styles placeholders"""

        fetchall_list = None

        try:
            sqlite_con, sqlite_cur = self.get_connect()

            if placeholder is None:
                res = sqlite_cur.execute(sql_query)

            elif isinstance(placeholder, tuple):
                res = sqlite_cur.execute(sql_query, placeholder)

            fetchall_list = res.fetchall()
            sqlite_cur.close()

            if verbose:
                print("All operation complete.")

        except sqlite3.Error as error:
            print("Error connection to sqlite:\n", error)
            if sys_exit:
                sys.exit(str(error))
        finally:
            if "sqlite_con" in locals() and sqlite_con:
                sqlite_con.close()
                if verbose:
                    print("Connection to SQLite closed.")

        return fetchall_list

    def safe_executescript(
        self, sql_script_fname=None, sql_script_str=None, verbose=False, sys_exit=True
    ):
        """Execute sql script from file or string
        See: https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.executescript
        """
        assert sql_script_fname or sql_script_str, "_fname or _str must be not None"

        if sql_script_fname:
            with open(sql_script_fname, "r") as sql_file:
                sql_script_str = sql_file.read()

        try:
            sqlite_con, sqlite_cur = self.get_connect()

            sqlite_cur.executescript(sql_script_str)

            sqlite_con.commit()
            sqlite_cur.close()

            if verbose:
                print("All operation complete.")

        except sqlite3.Error as error:
            print("Error connection to sqlite:\n", error)
            if sys_exit:
                sys.exit(str(error))
        finally:
            if "sqlite_con" in locals() and sqlite_con:
                sqlite_con.close()
                if verbose:
                    print("Connection to SQLite closed.")

    def print_db_schema(self, limit=10):
        """Print schema of all existing tables."""
        try:
            sqlite_con, sqlite_cur = self.get_connect()

            # get all tables
            res = sqlite_cur.execute(
                """
                SELECT
                    name
                FROM
                    sqlite_schema
                WHERE
                    type ='table' AND
                    name NOT LIKE 'sqlite_%';
                """
            )
            tables = tuple(map(lambda x: x[0], res.fetchall()))

            # print schema and data all tables
            for table in tables:
                print(f"Table: {table}")
                res = sqlite_cur.execute(
                    f"""
                    PRAGMA table_info({table});
                    """
                )
                print("\n".join(map(str, res.fetchall())))
                print("======SELECT * LIMIT 10======")
                res = sqlite_cur.execute(
                    f"""
                            SELECT * FROM {table}
                            LIMIT {int(limit)};
                            """
                )
                print("\n".join(map(str, res.fetchall())))
                print("=====================\n")

            sqlite_cur.close()

        except sqlite3.Error as error:
            print("Error connection to sqlite", error)
        finally:
            if "sqlite_con" in locals() and sqlite_con:
                sqlite_con.close()

    def to_transaction_queue(self, sql_query, placeholder=None, queue_name="default"):
        if queue_name not in self.transaction_queues:
            # create new queue if not exist
            self.transaction_queues[queue_name] = []

        self.transaction_queues[queue_name].append((sql_query, placeholder))

    def execute_transaction_queue(self, queue_name="default", verbose=False):
        self.safe_write_query(
            multiple_sql_queries=self.transaction_queues[queue_name], verbose=verbose
        )
        self.transaction_queues[queue_name].clear()
